import {
  createComponentForStaticNavigation,
  createPathConfigForStaticNavigation,
  type NavigationContainerRef,
  type ParamListBase,
  type StaticNavigation,
} from '@react-navigation/core';
import * as React from 'react';

import { NavigationContainer } from './NavigationContainer';
import type { LinkingOptions } from './types';

type Props = Omit<
  React.ComponentProps<typeof NavigationContainer>,
  'linking' | 'children'
> & {
  /**
   * Options for deep linking.
   */
  linking?: Omit<LinkingOptions<ParamListBase>, 'config' | 'enabled'> & {
    /**
     * Whether deep link handling should be enabled.
     * Defaults to `auto` unless `false` explicitly specified.
     *
     * When set to 'auto', all leaf screens will get autogenerated paths.
     * The generated paths will be kebab-case versions of the screen names.
     * This can be overridden for specific screens by specifying `linking` for the screen.
     */
    enabled?: 'auto' | true | false;
    /**
     * Additional configuration
     */
    config?: Omit<
      NonNullable<LinkingOptions<ParamListBase>['config']>,
      'screens'
    >;
  };
};

/**
 * Create a navigation component from a static navigation config.
 * The returned component is a wrapper around `NavigationContainer`.
 *
 * @param tree Static navigation config.
 * @returns Navigation component to use in your app.
 */
export function createStaticNavigation(tree: StaticNavigation<any, any, any>) {
  const Component = createComponentForStaticNavigation(tree, 'RootNavigator');

  function Navigation(
    { linking, ...rest }: Props,
    ref: React.Ref<NavigationContainerRef<ParamListBase>>
  ) {
    const linkingConfig = React.useMemo(() => {
      const screens = createPathConfigForStaticNavigation(
        tree,
        { initialRouteName: linking?.config?.initialRouteName },
        linking?.enabled == null || linking.enabled === 'auto'
      );

      if (!screens) return;

      return {
        path: linking?.config?.path,
        initialRouteName: linking?.config?.initialRouteName,
        screens,
      };
    }, [
      linking?.enabled,
      linking?.config?.path,
      linking?.config?.initialRouteName,
    ]);

    const memoizedLinking = React.useMemo(() => {
      const enabled =
        linking?.enabled == null || linking.enabled === 'auto'
          ? true
          : linking.enabled;

      return {
        ...linking,
        enabled,
        config: linkingConfig,
      };
    }, [linking, linkingConfig]);

    if (linking?.enabled === true && linkingConfig?.screens == null) {
      throw new Error(
        'Linking is enabled but no linking configuration was found for the screens.\n\n' +
          'To solve this:\n' +
          "- Specify a 'linking' property in each of the screen configs that you want to link to.\n" +
          "- Or set 'linking.enabled' to 'auto' to generate paths automatically.\n\n" +
          'See usage guide: https://reactnavigation.org/docs/static-configuration#linking'
      );
    }

    return (
      <NavigationContainer {...rest} ref={ref} linking={memoizedLinking}>
        <Component />
      </NavigationContainer>
    );
  }

  return React.forwardRef(Navigation);
}
