import * as fs from 'node:fs';
import { URL } from 'node:url';

const root = new URL('..', import.meta.url);
const assets = new URL('packages/native/assets/fonts/', root);

const VARIANTS = ['Outlined', 'Rounded', 'Sharp'];
const WEIGHTS = [100, 200, 300, 400, 500, 600, 700];

process.stdout.write('Updating Material Symbols...\n\n');

fs.mkdirSync(assets, { recursive: true });

const mappings = new Map<string, string>();

async function download(url: string, dest: URL): Promise<Buffer> {
  process.stdout.write(`Downloading ${dest.pathname.split('/').pop()}...`);

  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`Failed to download ${url}: ${response.statusText}`);
  }

  const buffer = Buffer.from(await response.arrayBuffer());

  fs.writeFileSync(dest, buffer);

  process.stdout.write(' done.\n');

  return buffer;
}

// Download the regular ttf file from Google Fonts
// The variable fonts in the Material Symbols repo are too large
for (const variant of VARIANTS) {
  for (const weight of WEIGHTS) {
    process.stdout.write(`Fetching font URL for ${variant} ${weight}...`);

    const cssResponse = await fetch(
      `https://fonts.googleapis.com/css2?family=Material+Symbols+${variant}:wght@${weight}`,
      {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        },
      }
    );

    if (!cssResponse.ok) {
      throw new Error(
        `Failed to fetch CSS for ${variant} ${weight}: ${cssResponse.statusText}`
      );
    }

    const css = await cssResponse.text();

    const fontUrlMatch = css.match(
      /url\((https:\/\/fonts\.gstatic\.com[^)]+)\)/
    );

    if (!fontUrlMatch) {
      throw new Error(
        `Could not find font URL in CSS for ${variant} ${weight}`
      );
    }

    const fontUrl = fontUrlMatch[1];

    process.stdout.write(' done.\n');

    const ttfDest = new URL(`MaterialSymbols${variant}_${weight}.ttf`, assets);

    await download(fontUrl, ttfDest);
  }

  const codepointsUrl = `https://github.com/google/material-design-icons/raw/master/variablefont/${encodeURIComponent(`MaterialSymbols${variant}[FILL,GRAD,opsz,wght].codepoints`)}`;
  const destCodepoints = new URL(
    `MaterialSymbols${variant}.codepoints`,
    assets
  );

  const codepointsBuffer = await download(codepointsUrl, destCodepoints);
  const codepoints = codepointsBuffer.toString('utf-8');

  for (const line of codepoints.split('\n')) {
    const trimmed = line.trim();

    if (trimmed) {
      const [name, codepoint] = trimmed.split(' ');

      if (name && codepoint) {
        const char = String.fromCodePoint(parseInt(codepoint, 16));

        mappings.set(name, char);
      }
    }
  }
}

process.stdout.write('\n');

fs.writeFileSync(
  new URL('packages/native/src/native/MaterialSymbolData.tsx', root),
  `// Auto-generated by scripts/update-material-symbols.ts
// Do not edit manually

export type MaterialSymbolName =
${[...mappings.keys()]
  .sort((a, b) => a.localeCompare(b))
  .map((name) => `  | '${name}'`)
  .join('\n')};
`
);

process.stdout.write(`Generated mappings with ${mappings.size} icon names.\n`);

fs.writeFileSync(
  new URL('example/src/material-symbol-names.ts', root),
  `// Auto-generated by scripts/update-material-symbols.ts
// Do not edit manually

export const MATERIAL_SYMBOL_NAMES = [
${[...mappings.keys()]
  .sort((a, b) => a.localeCompare(b))
  .map((name) => `  '${name}',`)
  .join('\n')}
] as const;
`
);

process.stdout.write('\nDone!\n');
